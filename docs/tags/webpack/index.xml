<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>webpack on NotEnough</title>
    <link>https://www.notenough.top/tags/webpack/</link>
    <description>Recent content in webpack on NotEnough</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 10 Sep 2021 09:44:45 +0800</lastBuildDate><atom:link href="https://www.notenough.top/tags/webpack/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Vite、esbuild以及webpack比较</title>
      <link>https://www.notenough.top/posts/viteesbuild%E4%BB%A5%E5%8F%8Awebpack%E6%AF%94%E8%BE%83/</link>
      <pubDate>Fri, 10 Sep 2021 09:44:45 +0800</pubDate>
      
      <guid>https://www.notenough.top/posts/viteesbuild%E4%BB%A5%E5%8F%8Awebpack%E6%AF%94%E8%BE%83/</guid>
      <description>一、前言 这三者的定位都有些不同，不好直接比较，但是做的事情还算类似，因此放一块拿来说说。vite 是新生技术，由其快速优秀的开发体验有取代 webpack 的趋势，但是它并不如 webpack 打包工具那么灵活，vite 内部的打包工具是采用的 esbuild，其性能之高也来自于此。
二、Vite2.0 特性  基于 esbuild 实现的极速开发体验 多框架支持 兼容 Rollup 的插件机制与 API SSR 支持 旧浏览器支持  三、在启动时，vite 为何比 webpack 快那么多？ 主要是 Vite 在开发模式没有做太多打包操作
Webpack 启动后会做一堆事情，经历一条很长的编译打包链条，从入口开始需要逐步经历语法解析、依赖收集、代码转译、打包合并、代码优化，最终将高版本的、离散的源码编译打包成低版本、高兼容性的产物代码，这可满满都是 CPU、IO 操作啊，在 Node 运行时下性能必然是有问题。
而 Vite 运行 Dev 命令后只做了两件事情，一是启动了一个用于承载资源服务的 service；二是使用 esbuild 预构建 npm 依赖包。之后就一直躺着，直到浏览器以 http 方式发来 ESM 规范的模块请求时，Vite 才开始“「按需编译」”被请求的模块。
这里 Vite 预设的前提是：
 现代浏览器大多数已经原生支持 ESM 规范，构建工具 —— 特别是开发环境下已经没有太大必要为了低版本兼容把大量的时间花在编译打包上了！  这么一对比，Webpack 是啥都做了，浏览器只要运行编译好的低版本(es5)代码就行；而 Vite 只处理问题的一部分，剩下的事情交由浏览器自行处理，那速度必然贼 TM 快。
除了启动阶段跳过编译操作之外，Vite 还有很多值得一提的性能优化，整体梳理一下：
 预编译：npm 包这类基本不会变化的模块，使用 Esbuild 在 「预构建」 阶段先打包整理好，减少 http 请求数 按需编译：用户代码这一类频繁变动的模块，直到被使用时才会执行编译操作 客户端强缓存：请求过的模块会被以 http 头 max-age=31536000,immutable 设置为强缓存，如果模块发生变化则用附加的版本 query 使其失效 产物优化：相比于 Webpack ，Vite 直接锚定高版本浏览器，不需要在 build 产物中插入过多运行时与模板代码 内置更好的分包实现：不需要用户干预，默认启用一系列智能分包规则，尽可能减少模块的重复打包 更好的静态资源处理：Vite 尽量避免直接处理静态资源，而是选择遵循 ESM 方式提供服务，例如引入图片 import img from &#39;xxx.</description>
    </item>
    
  </channel>
</rss>
