{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{415:function(t,s,a){\"use strict\";a.r(s);var r=a(56),n=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"js-对象的直接赋值、浅拷贝深拷贝\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js-对象的直接赋值、浅拷贝深拷贝\"}},[t._v(\"#\")]),t._v(\" JS 对象的直接赋值、浅拷贝深拷贝\")]),t._v(\" \"),a(\"p\",[t._v(\"date: 2021-11-21T17:18:23+08:00\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"直接赋值\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#直接赋值\"}},[t._v(\"#\")]),t._v(\" 直接赋值\")]),t._v(\" \"),a(\"p\",[t._v('把一个对象 a 赋值给一个对象 b 相当于把一个对象 b 的地址指向对象 a 的地址，所以，他们实际上是同一个对象。由于内存地址我们很难监测到，但是我们可以通过严格相等运算符\"===\"来检测二者是否指向同一个地址。')]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"直接赋值\")]),t._v(\"，修改赋值后的对象 b 的非对象属性，也\"),a(\"strong\",[t._v(\"会\")]),t._v(\"影响原对象 a 的\"),a(\"strong\",[t._v(\"非对象属性\")]),t._v(\"；修改赋值后的对象 b 的对象属性，也\"),a(\"strong\",[t._v(\"会\")]),t._v(\"影响原对象 a 的\"),a(\"strong\",[t._v(\"对象属性\")]),t._v(\"。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"浅拷贝\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#浅拷贝\"}},[t._v(\"#\")]),t._v(\" 浅拷贝\")]),t._v(\" \"),a(\"p\",[t._v(\"浅拷贝只会赋值制对象的非对象属性，不会指向同一个地址，而对象属性依然是指向同一个地址。\")]),t._v(\" \"),a(\"p\",[t._v(\"ES6 中有个浅拷贝的方法 Object.assign(target, ...sources)\")]),t._v(\" \"),a(\"p\",[t._v(\"修改赋值后的对象 b 的非对象属性，\"),a(\"strong\",[t._v(\"不会\")]),t._v(\"影响原对象 a 的\"),a(\"strong\",[t._v(\"非对象属性\")]),t._v(\"；修改赋值后的对象 b 的对象属性，却\"),a(\"strong\",[t._v(\"会\")]),t._v(\"影响原对象 a 的\"),a(\"strong\",[t._v(\"对象属性\")])]),t._v(\" \"),a(\"div\",{staticClass:\"language-js extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-js\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"var\")]),t._v(\" person \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token literal-property property\"}},[t._v(\"name\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"webber\"')]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token literal-property property\"}},[t._v(\"family\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token literal-property property\"}},[t._v(\"text\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"家\"')]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token literal-property property\"}},[t._v(\"age\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"2\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token literal-property property\"}},[t._v(\"age\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"15\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"var\")]),t._v(\" personCopy \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\nObject\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"assign\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"personCopy\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" person\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\npersonCopy \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"===\")]),t._v(\" person\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// false\")]),t._v(\"\\npersonCopy\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"family \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"===\")]),t._v(\" person\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"family\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//true\")]),t._v(\"\\n\")])])]),a(\"p\",[t._v(\"考虑到 es6 的支持程度，如果你的项目不支持 es6，但是又想实现浅拷贝的话，也可以尝试 js 原生的 concat 方法。但由于 concat 只能操作数组，所以需要先将 person 封装为一个对象数组，写成这种形式：\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v('var person=[{name:\"小明\",ageAndSex:{age:16,sex:\"男\"}}];')])]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"var personCopy=[].concat(person)；\")])]),t._v(\" \"),a(\"p\",[t._v(\"到时想得到 person 对象的时候 var personCopyObjet=pesronCopy[0]即可\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"深拷贝\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#深拷贝\"}},[t._v(\"#\")]),t._v(\" 深拷贝\")]),t._v(\" \"),a(\"p\",[t._v(\"深拷贝会另外拷贝一份一个一模一样的对象,但是不同的是会从堆内存中开辟一个新的区域存放新对象,新对象跟原对象不再共享内存，修改赋值后的对象 b 不会改到原对象 a。即\"),a(\"strong\",[t._v(\"深拷贝\")]),t._v(\"，修改赋值后的对象 b 的非对象属性，\"),a(\"strong\",[t._v(\"不会\")]),t._v(\"影响原对象 a 的\"),a(\"strong\",[t._v(\"非对象属性\")]),t._v(\"；修改赋值后的对象 b 的对象属性，也\"),a(\"strong\",[t._v(\"不会\")]),t._v(\"影响原对象 a 的\"),a(\"strong\",[t._v(\"对象属性\")]),t._v(\"。而且，二者不指向同一个对象。\")]),t._v(\" \"),a(\"p\",[t._v(\"深拷贝，比较笨一点的办法就是将自己需要的数据自己封装起来。\")]),t._v(\" \"),a(\"p\",[t._v(\"有一种非常简单的方法就是序列化成为一个 JSON 字符串，将对象的内容转换成字符串的形式，再用 JSON.parse()反序列化将 JSON 字符串变成一个新的对象，这样原对象就与复制后的新对象没了必然的关系。\")]),t._v(\" \"),a(\"p\",[t._v(\"但是由于用到了 JSON.stringify()，这也会导致一系列的问题，因为要严格遵守\"),a(\"strong\",[t._v(\"JSON 序列化规则\")]),t._v(\"：原对象中如果含有\"),a(\"strong\",[t._v(\"Date 对象\")]),t._v(\"，JSON.stringify()会将其变为字符串，之后并不会将其还原为日期对象。或是含有\"),a(\"strong\",[t._v(\"RegExp 对象\")]),t._v(\"，JSON.stringify()会将其变为空对象，属性中含有\"),a(\"strong\",[t._v(\"NaN\")]),t._v(\"、\"),a(\"strong\",[t._v(\"Infinity\")]),t._v(\"和**-Infinity**，则序列化的结果会变成 null，如果属性中有\"),a(\"strong\",[t._v(\"函数\")]),t._v(\",\"),a(\"strong\",[t._v(\"undefined\")]),t._v(\",\"),a(\"strong\",[t._v(\"symbol\")]),t._v(\"则经过 JSON.stringify()序列化后的 JSON 字符串中这个键值对会消失，因为不支持。这个时候只好使用笨点的方法。\")])])}),[],!1,null,null,null);s.default=n.exports}}]);","extractedComments":[]}